<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Casting</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600&family=Crimson+Text:ital,wght@0,400;1,400&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Crimson Text', Georgia, serif;
            background: #0d0a09;
            color: #a89080;
            min-height: 100vh;
            overflow-x: hidden;
        }

        /* Ambient ember particles */
        .ember-particle {
            position: fixed;
            width: 3px;
            height: 3px;
            background: #ff6b35;
            border-radius: 50%;
            pointer-events: none;
            opacity: 0;
            filter: blur(1px);
            animation: float-ember 4s ease-in-out infinite;
        }

        @keyframes float-ember {
            0% { transform: translateY(100vh) scale(0); opacity: 0; }
            10% { opacity: 0.8; }
            90% { opacity: 0.6; }
            100% { transform: translateY(-20px) scale(0.5); opacity: 0; }
        }

        /* Header */
        .header {
            text-align: center;
            padding: 40px 20px 20px;
        }

        .title {
            font-family: 'Cinzel', serif;
            font-size: 2.5rem;
            font-weight: 400;
            color: #ff6b35;
            letter-spacing: 0.15em;
            text-shadow: 0 0 30px rgba(255, 107, 53, 0.3);
            margin-bottom: 10px;
        }

        .subtitle {
            font-style: italic;
            font-size: 1.1rem;
            color: #6a5a4a;
        }

        /* Casting area */
        .casting-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            gap: 30px;
        }

        @media (min-width: 1000px) {
            .casting-container {
                flex-direction: row;
                align-items: flex-start;
                justify-content: center;
            }
        }

        .casting-field {
            position: relative;
            width: 90vw;
            max-width: 500px;
            height: 500px;
            background: 
                radial-gradient(ellipse at center, #1a1210 0%, #0d0a09 70%),
                repeating-conic-gradient(from 0deg, transparent 0deg, rgba(255,107,53,0.02) 1deg, transparent 2deg);
            border: 2px solid #2a1f1a;
            border-radius: 50%;
            box-shadow: 
                inset 0 0 60px rgba(0,0,0,0.8),
                0 0 40px rgba(255, 107, 53, 0.1);
            cursor: pointer;
            overflow: hidden;
        }

        .casting-field::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 60%;
            height: 60%;
            border: 1px solid rgba(255, 107, 53, 0.1);
            border-radius: 50%;
            pointer-events: none;
        }

        .casting-field::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 30%;
            height: 30%;
            border: 1px solid rgba(255, 107, 53, 0.15);
            border-radius: 50%;
            pointer-events: none;
        }

        .field-label {
            position: absolute;
            font-family: 'Cinzel', serif;
            font-size: 0.7rem;
            color: rgba(255, 107, 53, 0.3);
            letter-spacing: 0.1em;
            pointer-events: none;
        }

        .label-center { top: 50%; left: 50%; transform: translate(-50%, -50%); }
        .label-edge { bottom: 15px; left: 50%; transform: translateX(-50%); }

        .cast-prompt {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #4a3530;
            font-style: italic;
            pointer-events: none;
            transition: opacity 0.5s ease;
        }

        .cast-prompt.hidden {
            opacity: 0;
        }

        /* Bones/Symbols */
        .bone {
            position: absolute;
            font-size: 2rem;
            color: #e8dcd0;
            text-shadow: 0 0 10px rgba(255, 107, 53, 0.4);
            cursor: grab;
            user-select: none;
            transition: transform 0.1s ease, text-shadow 0.3s ease;
            filter: drop-shadow(2px 2px 3px rgba(0,0,0,0.8));
        }

        .bone:hover {
            text-shadow: 0 0 20px rgba(255, 107, 53, 0.8);
        }

        .bone.casting {
            animation: tumble 0.8s ease-out forwards;
        }

        @keyframes tumble {
            0% { 
                transform: translate(-50%, -50%) rotate(0deg) scale(2); 
                opacity: 0;
            }
            50% {
                transform: translate(-50%, -50%) rotate(var(--end-rotation)) scale(1.2);
                opacity: 1;
            }
            100% { 
                transform: translate(-50%, -50%) rotate(var(--end-rotation)) scale(1); 
                opacity: 1;
            }
        }

        /* Reading panel */
        .reading-panel {
            width: 90vw;
            max-width: 400px;
            background: linear-gradient(135deg, #1a1210 0%, #0d0a09 100%);
            border: 1px solid #2a1f1a;
            border-radius: 10px;
            padding: 25px;
            min-height: 400px;
        }

        .reading-title {
            font-family: 'Cinzel', serif;
            font-size: 1.2rem;
            color: #ff6b35;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid #2a1f1a;
        }

        .reading-content {
            font-size: 1rem;
            line-height: 1.8;
        }

        .reading-empty {
            color: #4a3530;
            font-style: italic;
            text-align: center;
            padding: 40px 0;
        }

        .relationship {
            margin: 20px 0;
            padding: 15px;
            background: rgba(255, 107, 53, 0.05);
            border-left: 2px solid #8b2500;
            border-radius: 0 5px 5px 0;
        }

        .relationship-bones {
            font-family: 'Cinzel', serif;
            font-size: 1.1rem;
            color: #ff6b35;
            margin-bottom: 8px;
        }

        .relationship-question {
            font-style: italic;
            color: #a89080;
        }

        .overall-pattern {
            margin-top: 25px;
            padding-top: 20px;
            border-top: 1px solid #2a1f1a;
        }

        .pattern-title {
            font-family: 'Cinzel', serif;
            font-size: 0.9rem;
            color: #8b2500;
            margin-bottom: 10px;
            letter-spacing: 0.1em;
        }

        .pattern-insight {
            font-style: italic;
            color: #6a5a4a;
        }

        /* Controls */
        .controls {
            text-align: center;
            padding: 20px;
        }

        .cast-btn {
            font-family: 'Cinzel', serif;
            font-size: 1rem;
            letter-spacing: 0.15em;
            padding: 15px 40px;
            background: linear-gradient(135deg, #2a1f1a 0%, #1a1210 100%);
            color: #ff6b35;
            border: 1px solid #4a3530;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .cast-btn:hover {
            background: linear-gradient(135deg, #3a2f2a 0%, #2a1f1a 100%);
            border-color: #ff6b35;
            box-shadow: 0 0 20px rgba(255, 107, 53, 0.2);
        }

        .cast-btn:active {
            transform: scale(0.98);
        }

        /* Footer wisdom */
        .footer {
            text-align: center;
            padding: 30px 20px;
            color: #4a3530;
            font-style: italic;
            font-size: 0.9rem;
            border-top: 1px solid #1a1210;
            margin-top: 20px;
        }

        /* Bone tooltip */
        .bone-tooltip {
            position: fixed;
            background: #1a1210;
            border: 1px solid #4a3530;
            padding: 10px 15px;
            border-radius: 5px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s ease;
            z-index: 100;
            max-width: 200px;
        }

        .bone-tooltip.visible {
            opacity: 1;
        }

        .tooltip-name {
            font-family: 'Cinzel', serif;
            color: #ff6b35;
            font-size: 0.9rem;
            margin-bottom: 5px;
        }

        .tooltip-desc {
            font-size: 0.8rem;
            color: #6a5a4a;
            font-style: italic;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1 class="title">THE CASTING</h1>
        <p class="subtitle">The bones remember what the flesh forgets</p>
    </div>

    <div class="casting-container">
        <div class="casting-field" id="castingField">
            <span class="field-label label-center">core</span>
            <span class="field-label label-edge">periphery</span>
            <div class="cast-prompt" id="castPrompt">
                Cast the bones into the fire's edge<br>and listen to where they fall
            </div>
        </div>

        <div class="reading-panel">
            <div class="reading-title">The Reading</div>
            <div class="reading-content" id="readingContent">
                <div class="reading-empty">
                    The field awaits your casting.<br><br>
                    Meaning emerges not from the symbols alone,<br>
                    but from how they fall together—<br>
                    and what you bring to the seeing.
                </div>
            </div>
        </div>
    </div>

    <div class="controls">
        <button class="cast-btn" id="castBtn">CAST THE BONES</button>
    </div>

    <div class="footer">
        "Connection to the system is required to interpret the message.<br>
        The symbols speak, but only to those who listen with relationship."
    </div>

    <div class="bone-tooltip" id="tooltip">
        <div class="tooltip-name"></div>
        <div class="tooltip-desc"></div>
    </div>

    <script>
        // The bones and their nature (not meanings - just nature)
        const bones = [
            { symbol: '◈', name: 'The Threshold', nature: 'passages, doorways, between-states' },
            { symbol: '◉', name: 'The Eye', nature: 'witnessing, being seen, attention' },
            { symbol: '△', name: 'The Flame', nature: 'transformation, consumption, illumination' },
            { symbol: '◇', name: 'The Vessel', nature: 'containing, holding, emptiness' },
            { symbol: '⬡', name: 'The Web', nature: 'connection, pattern, entanglement' },
            { symbol: '⊕', name: 'The Anchor', nature: 'grounding, center, gravity' },
            { symbol: '☽', name: 'The Shadow', nature: 'hidden things, cycles, reflection' },
            { symbol: '✧', name: 'The Spark', nature: 'beginning, potential, the unexpected' },
            { symbol: '⌘', name: 'The Knot', nature: 'complexity, binding, mystery' },
            { symbol: '∞', name: 'The River', nature: 'continuity, flow, return' },
            { symbol: '⟡', name: 'The Bone', nature: 'structure, memory, what remains' },
            { symbol: '◬', name: 'The Split', nature: 'choice, division, perspective' }
        ];

        // Questions that emerge from proximity
        const proximityQuestions = [
            "What passes through {a} to reach {b}?",
            "How does {a} illuminate {b}?",
            "What does {a} hold that {b} needs?",
            "Where do {a} and {b} meet in your life?",
            "What truth lives between {a} and {b}?",
            "How does {b} transform when {a} draws near?",
            "What are you not seeing where {a} touches {b}?",
            "What would {a} ask of {b}?",
            "In what way is {a} already {b}?"
        ];

        // Pattern insights based on distribution
        const patternInsights = {
            clustered: [
                "The bones gather close—something is converging in your life. What wants to come together?",
                "A tight constellation. The answer is not scattered; it waits in one place.",
                "Clustering speaks of intensity, focus, or perhaps avoidance of the edges."
            ],
            scattered: [
                "The bones spread wide—many threads, many directions. Where is your attention most needed?",
                "Scattering can mean expansion or fragmentation. Which feels true?",
                "The periphery calls as loudly as the center. Nothing wants to be ignored."
            ],
            centered: [
                "The core holds weight today. Something fundamental asks for attention.",
                "Gravity pulls inward. What sits at the center of your current question?",
                "The bones seek the middle ground—balance, or perhaps the eye of a storm."
            ],
            edgeHeavy: [
                "The edges speak louder than the center. What have you pushed to the periphery?",
                "Boundary work. The margins contain what the center cannot hold.",
                "What orbits your life without being allowed fully in?"
            ]
        };

        // Isolation insights
        const isolationInsights = [
            "{bone} stands alone. What in your life exists without witness or connection?",
            "Solitary {bone}—something asks to be seen in its singularity.",
            "{bone} keeps its own counsel. What do you hold apart from everything else?"
        ];

        let castBones = [];
        const field = document.getElementById('castingField');
        const readingContent = document.getElementById('readingContent');
        const castPrompt = document.getElementById('castPrompt');
        const tooltip = document.getElementById('tooltip');

        // Create ambient embers
        function createEmbers() {
            for (let i = 0; i < 15; i++) {
                const ember = document.createElement('div');
                ember.className = 'ember-particle';
                ember.style.left = Math.random() * 100 + 'vw';
                ember.style.animationDelay = Math.random() * 4 + 's';
                ember.style.animationDuration = (3 + Math.random() * 2) + 's';
                document.body.appendChild(ember);
            }
        }
        createEmbers();

        // Cast the bones
        document.getElementById('castBtn').addEventListener('click', () => {
            // Clear previous
            document.querySelectorAll('.bone').forEach(b => b.remove());
            castBones = [];
            castPrompt.classList.add('hidden');

            // Select 5-7 random bones
            const numBones = 5 + Math.floor(Math.random() * 3);
            const shuffled = [...bones].sort(() => Math.random() - 0.5);
            const selected = shuffled.slice(0, numBones);

            const fieldRect = field.getBoundingClientRect();
            const centerX = fieldRect.width / 2;
            const centerY = fieldRect.height / 2;
            const maxRadius = Math.min(centerX, centerY) - 40;

            // Cast each bone with delay
            selected.forEach((bone, i) => {
                setTimeout(() => {
                    const boneEl = document.createElement('div');
                    boneEl.className = 'bone casting';
                    boneEl.textContent = bone.symbol;
                    boneEl.dataset.name = bone.name;
                    boneEl.dataset.nature = bone.nature;

                    // Random position within circle
                    const angle = Math.random() * Math.PI * 2;
                    const distance = Math.random() * maxRadius;
                    const x = centerX + Math.cos(angle) * distance;
                    const y = centerY + Math.sin(angle) * distance;
                    const rotation = Math.random() * 360 - 180;

                    boneEl.style.left = x + 'px';
                    boneEl.style.top = y + 'px';
                    boneEl.style.setProperty('--end-rotation', rotation + 'deg');

                    // Store position data
                    castBones.push({
                        ...bone,
                        x: x,
                        y: y,
                        distanceFromCenter: distance / maxRadius, // 0 = center, 1 = edge
                        element: boneEl
                    });

                    // Tooltip on hover
                    boneEl.addEventListener('mouseenter', (e) => {
                        tooltip.querySelector('.tooltip-name').textContent = bone.name;
                        tooltip.querySelector('.tooltip-desc').textContent = bone.nature;
                        tooltip.style.left = e.pageX + 15 + 'px';
                        tooltip.style.top = e.pageY + 15 + 'px';
                        tooltip.classList.add('visible');
                    });

                    boneEl.addEventListener('mouseleave', () => {
                        tooltip.classList.remove('visible');
                    });

                    boneEl.addEventListener('mousemove', (e) => {
                        tooltip.style.left = e.pageX + 15 + 'px';
                        tooltip.style.top = e.pageY + 15 + 'px';
                    });

                    field.appendChild(boneEl);

                    // Generate reading after last bone
                    if (i === selected.length - 1) {
                        setTimeout(generateReading, 500);
                    }
                }, i * 200);
            });
        });

        function generateReading() {
            let html = '';

            // Find close pairs (proximity relationships)
            const pairs = [];
            for (let i = 0; i < castBones.length; i++) {
                for (let j = i + 1; j < castBones.length; j++) {
                    const dx = castBones[i].x - castBones[j].x;
                    const dy = castBones[i].y - castBones[j].y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance < 100) {
                        pairs.push({ a: castBones[i], b: castBones[j], distance });
                    }
                }
            }

            // Sort by closeness
            pairs.sort((a, b) => a.distance - b.distance);

            // Generate relationship questions for closest pairs (max 3)
            const closePairs = pairs.slice(0, 3);
            if (closePairs.length > 0) {
                closePairs.forEach(pair => {
                    const question = proximityQuestions[Math.floor(Math.random() * proximityQuestions.length)]
                        .replace('{a}', pair.a.name)
                        .replace('{b}', pair.b.name);
                    
                    html += `
                        <div class="relationship">
                            <div class="relationship-bones">${pair.a.symbol} ${pair.a.name} ↔ ${pair.b.symbol} ${pair.b.name}</div>
                            <div class="relationship-question">${question}</div>
                        </div>
                    `;
                });
            }

            // Find isolated bones
            const isolated = castBones.filter(bone => {
                return !pairs.some(p => p.a === bone || p.b === bone);
            });

            if (isolated.length > 0 && isolated.length <= 2) {
                isolated.forEach(bone => {
                    const insight = isolationInsights[Math.floor(Math.random() * isolationInsights.length)]
                        .replace('{bone}', bone.name);
                    html += `
                        <div class="relationship">
                            <div class="relationship-bones">${bone.symbol} ${bone.name} — alone</div>
                            <div class="relationship-question">${insight}</div>
                        </div>
                    `;
                });
            }

            // Determine overall pattern
            const avgDistance = castBones.reduce((sum, b) => sum + b.distanceFromCenter, 0) / castBones.length;
            const spread = Math.max(...castBones.map(b => b.distanceFromCenter)) - Math.min(...castBones.map(b => b.distanceFromCenter));

            let pattern;
            if (spread < 0.3 && avgDistance < 0.4) {
                pattern = 'centered';
            } else if (spread < 0.3 && avgDistance > 0.6) {
                pattern = 'edgeHeavy';
            } else if (spread < 0.4) {
                pattern = 'clustered';
            } else {
                pattern = 'scattered';
            }

            const patternInsight = patternInsights[pattern][Math.floor(Math.random() * patternInsights[pattern].length)];

            html += `
                <div class="overall-pattern">
                    <div class="pattern-title">THE PATTERN</div>
                    <div class="pattern-insight">${patternInsight}</div>
                </div>
            `;

            readingContent.innerHTML = html;
        }
    </script>
</body>
</html>
